---
title: "Gas Savings estimation explanation"
output: md_document
date: '2022-11-20'
---

```{r setupBase, include=FALSE}
# - INIT -----------------------------------------------------------------------
source("calc/prediction-gas-consumption/_shared.r")
source("export/analysis/_theme.r")
loadPackages(tidyverse, knitr)

days_of_months = c(31, 30, 31, 31, 28, 31)

### these values are taken from https://energie.gv.at/gut-zu-wissen/wie-wird-der-winter
gas.from.russia = 10
gas.from.russia.per.day = gas.from.russia / (sum(days_of_months))

gas.domestic = 4
gas.domestic.per.day = gas.domestic / (sum(days_of_months))

gas.from.others = 33
gas.from.others.per.day = gas.from.others / (sum(days_of_months))

### values from energie.gv.at (Eigentumsverhältnisse Gasspeicher)
### these values are not updated regularly
### I therefore update them proportional to emptying the complete gas storage
### Date of the initial data is 15/11/2022
storage.start.strategic = 20
storage.start.domestic = 27.09

storage.at = loadFromStorage("storage-AT") %>% 
    filter(year(gasDayStart) == 2022)  

storage.at.fill.state = storage.at %>% 
    filter(gasDayStart == "2022-11-15") %>% 
    mutate(value = gasInStorage)

storage.at.last = storage.at %>% 
    arrange(gasDayStart) %>% 
    slice_tail() %>% 
    mutate(value = gasInStorage)

proportion.domestic.international = (storage.start.domestic) / (storage.at.fill.state$value -  storage.start.strategic)

change.in.storage = (storage.at.fill.state$value - storage.at.last$value) * proportion.domestic.international

storage.start.domestic = storage.start.domestic - change.in.storage
```

# Reicht das Gas über den Winter?
<p class="meta">
    Datenstand: `r max(d.base$date)` | 
    Code: <a href="https://github.com/energy-monitor/explore/blob/main/analysis/gas-availability.rmd" target="_blank">↗</a>
</p>

Laut [energie.gv.at](https://energie.gv.at) lagen am 15.11.2022 `r storage.start.domestic` TWh Gas in österreichischen Speichern welches für österreichische Energiekonsument*innen bestimmt war. Dazu kommt die von der Bundesregierung betriebene strategische Gasreserve von 20 TWh. Im Zeitraum Oktober 2022 - März 2023 kann man außerdem mit einer österreichischen Gaseigenproduktion von 4 TWh rechnen - und mit Importen von 33 TWh. Falls Russland die Exporte stoppt, würden Importe von 22 TWh in der gesamten Periode erwartet werden. 

In der untenstehenden Grafik trainieren wir zuerst ein Modell, um den Gasverbrauch abhängig von der Außentemperatur abschätzen zu können. Und zwar trainieren wir es auf Daten für die 365 zurückliegenden Tage, um die aktuellen Verhaltensänderungen miteinzubeziehen. Dieses Modell verwenden wir in Folge, um bis Ende März den Verbrauch zu schätzen - und zwar für alle Außentemperaturen, die in diesem Zeitraum in den Jahren 1950 - 2021 geherrscht haben. Wir bekommen damit also 72 Verbrauchsszenarien. Aus diesen - und aus den Annahmen über zukünftige Gaslieferungen und die zuünftige Gasproduktion im Inland - können wir dann Szenarien für den Gasspeicherstand über den Winter berechnen. Der aktuelle Speicherstand wir so miteinbezogen, dass wir annehmen, dass die Abnahme im Speicherstand der österreichischen Kund/innen proportional zur Abnahme des Speicherstands der ausländischen Kund/innen erfolgt. 

Unsere Analyse berücksichtigt nicht die Preise an Märkten: in einem sehr kalten Winter würden die Preise massiv steigen, und der Verbrauch würde unter unserer Abschätzung liegen. Da wir rollierend die Temperaturabhängigkeit schätzen, fließt der Effekt sich verändernder Preise aber nur langsam ins Modell ein. Würde der Winter sehr warm, würden die Preise fallen, und der Verbrauch steigen, die Einsparungen wären also geringer, als von uns abgeschätzt. In Summe sollte der Preiseffekt also dazu führen, dass der Speicherstand am Ende des Winters innerhalb der von uns ausgewiesenen Spannbreite liegt: wird der Winter sehr kalt, würde mehr gespart werden als von uns vorhergesagt, wird er sehr warm, weniger.

```{r setupData, include=FALSE}

d.base = loadBase(update = TRUE)

temp.threshold = 14

d.comb = copy(d.base)
d.comb[, `:=`(
    temp.below.threshold = ifelse(temp < temp.threshold, temp.threshold - temp, 0),
    temp.above.threshold = ifelse(temp > temp.threshold, temp - temp.threshold, 0)
)]

d.comb[, `:=`(
    week = str_pad(week, 2, pad = "0"),
    temp.below.threshold.squared = temp.below.threshold^2,
    temp.below.threshold.lag = shift(temp.below.threshold, 1),
    year_character = as.character(year)
)]

model.base = value ~
    #t + t.squared + # week + 
    temp.below.threshold + temp.below.threshold.lag + temp.below.threshold.squared + 
    wday + is.holiday + as.factor(vacation.name) 

max.date = max(d.comb$date)

d.train = d.comb[(date > (max.date - 365))]

m.linear = lm(model.base, data = d.train)

d.hdd = loadFromStorage(id = "temperature-hdd")[, `:=`(
        date = as.Date(date)
    )]

d.hdd = d.hdd[, c("date", "temp")]
d.hdd = d.hdd[, `:=` (date = date - 90)]
d.hdd[ , `:=` (day = yday(date),
               year = year(date)), ]



one.prediction = function(year.select, temp.in, m.linear, d.base) {
    
    temp.in = temp.in[year == year.select]
    
    d.prediction = copy(d.base)

    
    
    d.prediction[, `:=`(
        temp.below.threshold = ifelse(temp < temp.threshold, temp.threshold - temp, 0),
        temp.above.threshold = ifelse(temp > temp.threshold, temp - temp.threshold, 0)
    )]

    d.prediction[ , `:=`(week = str_pad(week(date), 2, pad = "0"),
        wday = factor(as.character(clock::date_weekday_factor(date)),
                      c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")),
        temp.below.threshold.squared = temp.below.threshold^2,
        temp.below.threshold.lag = shift(temp.below.threshold, 1),
        year_character = as.character(year)
    )]
    
    d.prediction[ ,`:=`(date = date + 365), ]

    d.prediction = d.prediction[date > max.date & date < "2023-04-01"]
    
    d.prediction[ ,`:=`(date = date - 90), ]
    
    d.prediction[ ,`:=`(day = yday(date)), ]

    
    d.prediction = merge(d.prediction, temp.in, by = "day")[, `:=` (temp = temp.y), ]
    
     d.prediction[, `:=`(
        temp.below.threshold = ifelse(temp < temp.threshold, temp.threshold - temp, 0),
        temp.above.threshold = ifelse(temp > temp.threshold, temp - temp.threshold, 0)
    )]
    
    prediction = predict(m.linear, d.prediction)

    d.prediction[ , `:=`(day = day,
                         year = year.y,
                     value = cumsum(prediction),
                     storage.strategic = storage.start.strategic,
                     storage.domestic = storage.start.domestic,
                     gas.from.russia = gas.from.russia.per.day,
                     gas.other = gas.from.others.per.day + gas.domestic.per.day)]


    d.prediction[ , `:=`(storage.with.russia = storage.domestic + storage.strategic - value + cumsum(gas.from.russia) + cumsum(gas.other),
                     storage.without.russia = storage.domestic + storage.strategic - value + cumsum(gas.other))]

    d.prediction = d.prediction %>% 
        dplyr::select(day,
                      year,
                  storage.with.russia,
                  storage.without.russia,
                  ) %>% 
        gather(variable, value, -day, -year) %>% 
        mutate(year = year.select)
    
    return(d.prediction)
}

d.all.years = bind_rows(lapply(1950:2021, one.prediction, d.hdd, m.linear, d.base)) %>% as.data.table()

d.all.years[ ,`:=` (day.name = day + 90)]

d.all.years[ ,`:=` (date = (as.Date(day.name, origin = "2022-01-01"))),]

annotation <- tibble(
    label = c(
        "Strategische Gasreserve", 
        ""
    ),
    x = c(as.Date("2023-01-01")),
    y = c(22)
)

d.all.years %>% 
    mutate(variable = ifelse(variable == "storage.with.russia", "Mit russischem Gas", "Ohne russisches Gas")) %>% 
    ggplot(aes(x = date, y = value)) +
    geom_line(aes(col = as.character(year)), size = 0.3, alpha = 0.5) +
    facet_wrap(.~variable) +
    geom_abline(slope = 0, intercept = storage.start.strategic, linetype = 2) +
    ylim(c(0, storage.start.strategic + storage.start.domestic + 2)) +
    scale_color_manual(values = rgb((1:72)/ 72, 0, 0), guide = "none") +
    xlab("") +
    ylab("Speicherniveau (TWh)") +
    geom_text(data = annotation, aes(x = x, y = y, label = label), size = 3)


```


